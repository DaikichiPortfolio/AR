<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>XYZ Point Cloud AR</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/ARButton.js';

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera();

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ['hit-test']
      }));

      // ヒットテスト用変数
      let controller;
      let reticle;
      let hitTestSource = null;
      let localSpace = null;
      let pointCloud = null;

      // カーソル表示（平面を検出した位置）
      reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.1, 0.15, 32).rotateX(-Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // コントローラー（タップ検出）
      controller = renderer.xr.getController(0);
      scene.add(controller);

      // ユーザーがタップ → 点群をリテクル位置に配置
      controller.addEventListener('select', () => {
        if (reticle.visible && pointCloud) {
          pointCloud.position.setFromMatrixPosition(reticle.matrix);
          pointCloud.visible = true;
        }
      });

      // ARセッション開始 → ヒットテストセットアップ
      renderer.xr.addEventListener('sessionstart', async () => {
        const session = renderer.xr.getSession();
        const viewerSpace = await session.requestReferenceSpace('viewer');
        hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
        localSpace = await session.requestReferenceSpace('local');

        session.addEventListener('end', () => {
          hitTestSource = null;
          localSpace = null;
        });
      });

      // 点群読み込み
      fetch('pointcloud_tameshi.xyz')
        .then(res => {
          if (!res.ok) throw new Error('点群ファイルの読み込みに失敗しました');
          return res.text();
        })
        .then(text => {
          const lines = text.trim().split('\n');
          const positions = new Float32Array(lines.length * 3);
          const colors = new Float32Array(lines.length * 3);

          lines.forEach((line, i) => {
            const [x, y, z, r, g, b] = line.trim().split(/\s+/).map(Number);
            positions.set([x, y, z], i * 3);
            colors.set([r / 255, g / 255, b / 255], i * 3);
          });

          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

          // 中心に合わせる（オプション）
          const center = new THREE.Vector3();
          for (let i = 0; i < positions.length; i += 3) {
            center.add(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));
          }
          center.divideScalar(positions.length / 3);
          geometry.translate(-center.x, -center.y, -center.z);

          const material = new THREE.PointsMaterial({
            size: 0.01,
            sizeAttenuation: true,
            vertexColors: true,
          });

          pointCloud = new THREE.Points(geometry, material);
          pointCloud.visible = false;
          scene.add(pointCloud);
        })
        .catch(err => {
          console.error('点群読み込みエラー:', err);
        });

      // 毎フレーム処理
      renderer.setAnimationLoop((timestamp, frame) => {
        if (frame && hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(localSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }

        renderer.render(scene, camera);
      });
    </script>
  </body>
</html>
